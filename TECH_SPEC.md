# Техническая спецификация

Этот документ описывает архитектурные решения и технические детали, использованные при создании разговорного помощника по покупкам.

## Архитектурные решения

-   **Монолитная архитектура**: Вся основная логика приложения заключена в одном файле (`advisor.py`) для простоты и удобства развертывания, что соответствует требованиям тестового задания.
-   **Разделение логики**: Несмотря на монолитность, проект имеет четкое разделение на компоненты:
    -   `advisor.py`: Основной файл, содержащий UI и оркестрацию.
    -   `retrieval.py`: Модуль, отвечающий за извлечение и фильтрацию данных.
    -   `prompts.py`: Хранит все системные промпты и примеры для LLM.
    -   `tests/`: Содержит все модульные тесты.
-   **Использование Pydantic**: Все модели данных (продукты, варианты, и т.д.) определены с использованием Pydantic для строгой типизации и валидации данных. Это также используется для определения схем инструментов, передаваемых в LLM.
-   **Оркестрация на основе намерений (Intent-Based Orchestration)**:
    -   Приложение сначала классифицирует намерение пользователя (поиск, сравнение, и т.д.) с помощью LLM.
    -   Затем, в зависимости от намерения, вызывается соответствующий обработчик.
    -   Этот подход позволяет легко расширять функциональность, добавляя новые намерения и обработчики.
-   **Retrieval-Augmented Generation (RAG)**:
    -   Для ответов на вопросы, требующие данных (например, поиск товаров), используется RAG.
    -   LLM сначала определяет, какие фильтры применить, и вызывает инструмент `ProductSearchTool`.
    -   Затем результаты поиска передаются в LLM для генерации ответа на естественном языке.

## Технологический стек

-   **Python >= 3.10**: Современная версия Python, обеспечивающая доступ к новым возможностям языка.
-   **Streamlit**: Используется для создания интерактивного веб-интерфейса.
-   **OpenAI API**: Применяется для доступа к LLM (GPT-4.1-nano).
-   **Pydantic**: Для валидации данных и создания схем.
-   **Rapidfuzz**: Для нечеткого поиска и исправления опечаток с использованием расстояния Левенштейна.
-   **Pytest**: Для написания и запуска модульных тестов.

## Обработка опечаток

-   Для обработки опечаток в названиях товаров используется расстояние Левенштейна.
-   Функция `_is_match` в `retrieval.py` сравнивает запрос пользователя с названиями товаров, их псевдонимами и ключевыми словами.
-   Соответствие считается найденным, если расстояние Левенштейна меньше или равно 2.

## Управление состоянием и историей

-   История диалога хранится в состоянии сессии Streamlit (`st.session_state`).
-   Для предотвращения переполнения контекстного окна модели, история диалога обрезается до последних 5 пар сообщений (10 сообщений).
-   API ключ OpenAI безопасно управляется с помощью Streamlit Secrets, с возможностью ввода ключа пользователем, если он не найден.
